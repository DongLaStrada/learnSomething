# 分区

分区：partitions 也称为sharding，是一种有意将大型数据库分解成小型数据库的方式（与网络分区无关，这是节点之间的网络中的一种故障类型）

术语澄清：parttions 在MongoDB，elasticsearch和Solr Cloud中被称为分片（shard）在HBase中被称为区域（Region），Bigtable中成为表块（tablet），等 即分区是一个约定俗称的叫法

通常请款每条数据属于一个分区，尽管数据库可能支持同时进行多个分区的操作。

---
分区的目标：是将数据和查询负载均匀分布在各个节点上。如果分区不公平，一些分区比其他分区有更多的数据或者查询，我们称之为偏斜（shew）。数据偏斜降低了分区都得效率。不均衡导致的高负载分区被称为热点（hot spot）

---

“随机平均分配”可以避免数据热点，但是试图查询的时候必须查询所有节点。

键值数据的分区：
1. 键的范围分区：每个分区指定一块连续的键范围，确定这个范围之间的边界，键的范围不一定均匀，因为数据可能不均匀，每个分区按照一定的顺序保存键值（参考SSTables和LSM树）。某些特定访问会导致热点或者偏斜
2. 键的散列分区：降低偏斜和热点风险，例如32位散列函数，该技术也被称为一致性哈希。不利于之后的在重新平衡分区，丧失了高效的范围查询能力。（折衷策略，例如Cassandra键中第一列用散列索引，对其他列可以范围索引）
3. 负载倾斜与消除热点：极端情况下，读写操作都针对同一个键，所有请求都在一个分区，导致高度偏斜的负载。（简单的方法是主键结尾添加一个十进制两位数，就可以将主键分散为100种不同主键存在不同分区，但是这样数据的读取和合并都要有额外记录）
4. 次级索引：次级索引不能整齐的映射到分区。有两种二级索引对数据库分区的方法：基于文档的分区 和 基于关键词的分区(间歇性写入失败，竞争条件容易导致索引和数据不一致，基于文档的分区建立本地索引，查询时需要多个本地索引聚合 ，**查询速度比较慢**。关键词分区建立全局索引，写入的时候影响多个分区比较复杂，**写入的时候比较慢**)
5. 分区在平衡：将负载从集群中的一个节点向另一个节点移动的过程称为再平衡（reblancing）。再平衡后需要满足，集群节点公平共享、再平衡发生时数据库可继续读取和写入、节点之间只移动必须的数据，以便快速在平衡，减少网络磁盘io
6. 平衡策略： ***固定数量分区***，即分区数量大于节点数量（例如：10个节点1000个分区），新节点加入集群中，新节点从当前每个节点中窃取一些分区直到分区再次平衡（符合最小IO开销），分区的管理也有开销，分区过多可能适得其反，分区非常大，再平衡和从节点故障恢复比较昂贵。固定分区在**数据变动很大**的情况下，难以达到性能最佳。***动态分区***，即按照键的范围分区，动态创建分区，反之大量数据删除的时候，分区缩小到某个阈值以下则合并分区（类似B-tree），优点分区适应总数据量。***按节点比例分区***分区的数量与数据集的大小成正比


---
请求路由：

服务发现（service discovery）：
1. 允许客户联系任何节点。如果恰好有请求分区，则直接处理该请求；否则，他将请求转发到适当的节点，接收回复并传递给客户端。（节点之一）
2. 首先将所有客户请求都发送路由层，再由路由层转发。路由层不处理逻辑，仅负责分区的均衡负载。（路由层）
3. 客户端知道分区和节点的分配。客户端直接找到适应的节点，不需要中介。（客户端）

独立协调服务器，例如zookeeper，跟踪元数据，维护分区到节点的可靠映射。其他参与者可在zookeeper中订阅此信息。只要分区分配集群几点发生改变。zookeeper就会通知路由层使路由信息保持最新状态。

引入问题：大规模数据并行查询，**MPP**（大规模并行处理 Massively parallel processing）查询优化器，将复杂的查询分解成许多执行阶段和分区。